
function myga_TSP2(edgenum)

    % mainly amended by Chen Zhen, 2012~2016

    CiteNum = 12;
    BitNum=(CiteNum-1)*CiteNum/2; %you chan choose 10, 30, 50, 75
    [Clist,CityLoc,CityPop]=testcase;% clist是直角坐标系坐标

    population_size=70; %初始种群大小
    parent_number = 50;
    child_num = population_size - parent_number;
    gnmax=500;  %最大代数
    pc=0.8; %交叉概率
    mutation_rate=0.8; %变异概率

    %产生初始种群
    population=zeros(parent_number,edgenum);
    i = 1;
    while i <= parent_number
        temp = randperm(BitNum);
        if test_liantong(temp(1:edgenum))==1
            population(i,:) = temp(1:edgenum);
            i = i+1;
        end
    end
    population=die(population);
    length(population)
    [~,p]=objf(population,Clist,CityPop,edgenum);

    gn=1;
    fopt=zeros(gn,1);
    xmax=zeros(gnmax,edgenum);%第几代
    scnew=zeros(child_num,edgenum);%孩子
    smnew=zeros(child_num,edgenum);%变异，先生孩子，然后变异
    while gn<gnmax+1
        for j=1:2:child_num
            seln=sel(population);  %选择操作
            scro=cro(population,seln,pc);  %交叉操作
            scnew(j,:)=scro(1,:);
            scnew(j+1,:)=scro(2,:);
            smnew(j,:)=mut(scnew(j,:),mutation_rate);  %变异操作
            smnew(j+1,:)=mut(scnew(j+1,:),mutation_rate);
        end
        smnew=die(smnew);
        population1=[population;smnew];  %产生了新的种群
        for i = 1:size(smnew,1)
            i
            flag = test_liantong(smnew(i,:))
            assert (flag==1);
        end
        [f,p]=objf(population1,Clist,CityPop,edgenum);  %计算新种群的适应度
            % index记录排序后每个值原来的行数
        [f, index] = sort(f,'descend') % 将适应度函数值从小到大排序
        population = population1(index(1:parent_number), :); % 先保留一部分较优的个体
        %记录当前代最好和平均的适应度
        

        %ymean(gn)=1000/mean(f);
        %ymax(gn)=1000/fmax;
        %记录当前代的最佳个体
        x=population(1,:);
        xmax(gn,:)=x;
        gn=gn+1;
        fopt(gn) = fobj(x(end,1:edgenum),Clist,CityPop);
    end

    [f,X]=fobj(xmax(end,1:edgenum),Clist,CityPop);
    
    X=tril(get_adjacency(xmax(end,1:edgenum)))
    figure;clf;hold on;
    plot(CityLoc(:,2),CityLoc(:,1),'rs');
    for ii=1:CiteNum
        for jj=1:CiteNum
            if (X(ii,jj)==1)
                plot([CityLoc(ii,2) CityLoc(jj,2)],...
                    [CityLoc(ii,1) CityLoc(jj,1)],'b-');
            end
        end
    end
    title(['容量为' num2str(f)])
    ylabel('纬度');
    xlabel('经度');
    figure;
    plot(fopt);
    ylabel('网络价值');
    xlabel('迭代次数');
    title(['连接数为' num2str(edgenum)]);
    pause(0.01);
    figure;
end

%------------------------------------------------
%计算所有种群的适应度,返回价值向量和累计概率
function [cost,p]=objf(population,Clist,CityPop,edgenum)

    inn=size(population,1);  %读取种群大小
    cost=zeros(inn,1);
    for i=1:inn
        cost(i)=fobj(population(i,1:edgenum),Clist,CityPop);  %计算函数值，即适应度
    end
    cost=cost'; %取距离倒数
    %根据个体的适应度计算其被选择的概率
    fsum=0;
    for i=1:inn
        fsum=fsum+cost(i)^15;% 让适应度越好的个体被选择概率越高
    end
    ps=zeros(inn,1);
    for i=1:inn
        ps(i)=cost(i)^15/fsum;
    end

    %计算累积概率
    p=zeros(inn,1);
    p(1)=ps(1);
    for i=2:inn
        p(i)=p(i-1)+ps(i);
    end
    p=p';
end

%--------------------------------------------------
%根据变异概率判断是否变异
function pcc=pro(pc)
    test(1:100)=0;
    l=round(100*pc);
    test(1:l)=1;
    n=round(rand*99)+1;
    pcc=test(n);
end

%--------------------------------------------------
%“选择”操作
function seln=sel(p)
    seln=zeros(2,1);
    num = size(p,1);
    c1 = randi([1 num]);
    c2 = randi([1 num]);
    while c1 == c2
        c2 = randi([1 num]);
    end
    seln(1)=c1;
    seln(2)=c2;
end

%------------------------------------------------
%“交叉”操作
function scro=cro(population,seln,pc)

    edgenum=size(population,2);
    pcc=pro(pc);  %根据交叉概率决定是否进行交叉操作，1则是，0则否
    scro(1,:)=population(seln(1),:);%选择的
    scro(2,:)=population(seln(2),:);
    if pcc==1
        c1 = randi([1 edgenum]);
        middle=scro(1,1:c1);
        scro(1,1:c1)=scro(2,1:c1);
        scro(2,1:c1)=middle;
    end
end

%--------------------------------------------------
%“变异”操作
function snnew=mut(snew,mutation_rate)
    snnew=snew;
    edgenum=size(snew,2);
    mutation_ratem=pro(mutation_rate);  %根据变异概率决定是否进行变异操作，1则是，0则否
    if mutation_ratem==1
        c1 = randi([1 edgenum]);
        snnew(c1) = randi([1 66]);
    end
end

function population = die(population)
    global line_info;
    delete=[];
    delete_index = 1;
    row_num = size(population,1)
    edge_num = size(population,2)
    i = 1;
    while i<=row_num
        if length(unique(population(i,:)))~=edge_num
            delete(delete_index)=i;
            delete_index=delete_index+1;
            i=i+1;
            continue;
        end
        arr = eye(12);
        num =0;
        for line_id=1:edge_num
            line_index=population(i,line_id);
            x=0;y=0;
            x = line_info(line_index,1);
            y = line_info(line_index,2);
            arr(x,y)=1;
            num=num+1;
        end
        arr1 = arr+arr';
        %view(biograph(arr,[],'ShowArrows','off','ShowWeights','on'));% 显示图
        if ~canget(arr1)
            delete(delete_index)=i;
            delete_index=delete_index+1;
            i=i+1;
            continue;
        end
        i=i+1;
         
    end
    population(delete,:)=[]
    for i =1:size(population,1)
        i
        assert (test_liantong(population(i,:))==1);
    end

end
function flag=canget(A)
    n=length(A);
    P=A;
    for i1=2:n
        P=P+A^i1;
    end
    flag = all(all(P));
end

function adjacency=get_adjacency(array16) 
    arr=eye(12);
    global line_info;
    num =0;
    for line_id=1:16
        line_index=array16(line_id);
        x1 = line_info(line_index,1);
        y1 = line_info(line_index,2);
        arr(x1,y1)=1;
        num=num+1;
    end
    adjacency=arr+arr';
end 
function flag=test_liantong(array16)
    adjacency=get_adjacency(array16);
    flag = canget(adjacency);
end
function [Clist,CityLoc,CityNum]=testcase
    CityLoc=[39.91667 116.41667;
        45.75000 126.63333;
        43.45 87.36;
        34.26667,108.95000;
        34.76667,113.65000;
        31.14 121.29;
        30.35 114.17;
        29.35 106.33;
        30.40 104.04;
        29.39 91.08;
        25.04 102.42;
        23.16667,113.23333];
    CityNum = [1961.24 1063.60 311.03 846.78 862.65 2301.91 978.54 2884.62 1404.76...
        55.94 643.20 1035.79];

    axesm utm   %设置投影方式，这是MATLAT自带的Universal Transverse Mercator （UTM）方式
    Z=utmzone(CityLoc);%utmzone根据latlon20里面的数据选择他认为合适的投影区域，可以是一个台站的经纬度，也可以是所有台站的经纬度（此时是平均）
    setm(gca,'zone',Z)
    h = getm(gca);
    R=zeros(size(CityLoc));
    for i=1:length(CityLoc)
        [x,y]= mfwdtran(h,CityLoc(i,1),CityLoc(i,2));
        Clist(i,:)=[x;y]/1e3;
    end
end
